/**
 * lua-style assert helper.
 * Throws `message` if `val` is falsy.
 */
/**
 * Get the Object.prototype.toString version of a value.
 */
function tagOf(val) {
    return Object.prototype.toString.call(val);
}
/**
 * Normalize binary values into Uint8Array
 */
function normalizeBinary(data) {
    // Wrap raw ArrayBuffer values in Uint8Array
    const tag = tagOf(data);
    if (tag === "[object ArrayBuffer]") {
        return new Uint8Array(data);
    }
    // Normalize all ArrayBufferView types into Uint8Array
    if (ArrayBuffer.isView(data)) {
        if (tag === "[object Uint8Array]") {
            return data;
        }
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
    return null;
}
/** Convert an utf8 encoded Uint8Array into a unicode string (with surrogate pairs.) */
function utf8Decode(bin) {
    // tslint:disable: no-bitwise
    let str = "";
    for (let i = 0, l = bin.length; i < l;) {
        const byte = bin[i++];
        const codePoint = byte < 0x80
            ? byte
            : byte >= 0xc0 && byte < 0xe0
                ? (byte & 0x1f) << 6 |
                    bin[i++] & 0x3f
                : byte >= 0xe0 && byte < 0xf0
                    ? (byte & 0xf) << 12 |
                        (bin[i++] & 0x3f) << 6 |
                        bin[i++] & 0x3f
                    : byte >= 0xf0 && byte < 0xf8
                        ? (byte & 0x7) << 18 |
                            (bin[i++] & 0x3f) << 12 |
                            (bin[i++] & 0x3f) << 6 |
                            bin[i++] & 0x3f
                        : -1;
        if (codePoint < 0) {
            throw new Error("Invalid UTF-8 value found in decoding");
        }
        str += String.fromCodePoint(codePoint);
    }
    return str;
}
function utf8Length(str) {
    let sizeNeeded = 0;
    const length = str.length;
    for (let i = 0; i < length; i++) {
        const codePoint = str.codePointAt(i);
        if (codePoint < 0x80) {
            sizeNeeded++;
        }
        else if (codePoint < 0x800) {
            sizeNeeded += 2;
        }
        else if (codePoint < 0x10000) {
            sizeNeeded += 3;
        }
        else {
            i++;
            sizeNeeded += 4;
        }
    }
    return sizeNeeded;
}
/** Convert a unicode string (with surrogate pairs) into an utf8 encoded Uint8Array */
function utf8Encode(str) {
    const length = utf8Length(str);
    const buffer = new Uint8Array(length);
    let offset = 0;
    for (let i = 0; i < length; i++) {
        const codePoint = str.codePointAt(i);
        if (codePoint < 0x80) {
            buffer[offset++] = codePoint;
        }
        else if (codePoint < 0x800) {
            buffer[offset++] = 0xc0 | (codePoint >> 6);
            buffer[offset++] = 0x80 | (codePoint & 0x3f);
        }
        else if (codePoint < 0x10000) {
            buffer[offset++] = 0xe0 | (codePoint >> 12);
            buffer[offset++] = 0x80 | ((codePoint >> 6) & 0x3f);
            buffer[offset++] = 0x80 | (codePoint & 0x3f);
        }
        else {
            i++;
            buffer[offset++] = 0xf0 | (codePoint >> 18);
            buffer[offset++] = 0x80 | ((codePoint >> 12) & 0x3f);
            buffer[offset++] = 0x80 | ((codePoint >> 6) & 0x3f);
            buffer[offset++] = 0x80 | (codePoint & 0x3f);
        }
    }
    return buffer;
}
function pathJoin(base, ...inputs) {
    const segments = [];
    for (const part of (base + "/" + inputs.join("/")).split(/\/+/)) {
        if (part === "" || part === ".") {
            continue;
        }
        if (part === "..") {
            segments.pop();
            continue;
        }
        segments.push(part);
    }
    return (base[0] === "/" ? "/" : "") + segments.join("/");
}

export { normalizeBinary, pathJoin, tagOf, utf8Decode, utf8Encode, utf8Length };
