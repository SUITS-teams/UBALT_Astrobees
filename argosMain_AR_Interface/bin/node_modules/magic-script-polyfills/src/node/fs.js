import { fs, Fs } from 'uv';
import { utf8Decode, utf8Encode, normalizeBinary } from '../utils2.js';
import { openSync, readSync, closeSync, writeSync } from '../fs-uv.js';

function unlinkSync(path) {
    fs.unlink(new Fs(), path);
}
function readdirSync(path) {
    const req = fs.scandir(new Fs(), path, 0);
    let entry;
    const names = [];
    // tslint:disable-next-line: no-conditional-assignment
    while ((entry = fs.scandirNext(req))) {
        names.push(entry.name);
    }
    return names;
}
function readFileSync(path, rawOptions) {
    const flag = typeof rawOptions === "object" && rawOptions && typeof rawOptions.flag !== "undefined"
        ? rawOptions.flag : "r";
    const encoding = typeof rawOptions === "string"
        ? rawOptions
        : typeof rawOptions === "object" && rawOptions && typeof rawOptions.encoding === "string"
            ? rawOptions.encoding : null;
    if (encoding !== null && encoding !== "utf8" && encoding !== "utf-8") {
        throw new Error(`Unsupported encoding requested: ${encoding}`);
    }
    const parts = [];
    let size = 0;
    const buffer = new Uint8Array(1024 * 16);
    const fd = openSync(path, flag, 0o666);
    try {
        let bytesRead;
        // tslint:disable-next-line: no-conditional-assignment
        while (bytesRead = readSync(fd, buffer, -1)) {
            parts.push(buffer.slice(0, bytesRead));
            size += bytesRead;
        }
    }
    finally {
        closeSync(fd);
    }
    return joinParts(parts, size, encoding);
}
function joinParts(parts, size, encoding) {
    const data = new Uint8Array(size);
    let offset = 0;
    for (const part of parts) {
        data.set(part, offset);
        offset += part.byteLength;
    }
    return encoding === null ? data : utf8Decode(data);
}
function writeFileSync(pathOrFd, textOrBinary, rawOptions) {
    const { mode, flag, array } = normalizeWriteFileInputs(textOrBinary, rawOptions);
    const fd = typeof pathOrFd === "number"
        ? pathOrFd
        : openSync(pathOrFd, flag, mode);
    try {
        writeSync(fd, array, -1);
        // TODO: find out if we need to check bytesWritten here.
        // I'm assuming the entire buffer is written.
    }
    finally {
        closeSync(fd);
    }
}
function normalizeWriteFileInputs(textOrBinary, rawOptions) {
    const options = typeof rawOptions === "object" && rawOptions
        ? rawOptions
        : {};
    const encoding = typeof textOrBinary === "string"
        ? typeof rawOptions === "string"
            ? rawOptions
            : typeof options.encoding === "string"
                ? options.encoding
                : "utf8"
        : null;
    if (encoding !== null && encoding !== "utf8" && encoding !== "utf-8") {
        throw new Error(`Unsupported encoding requested: ${encoding}`);
    }
    const mode = typeof options.mode === "number"
        ? options.mode
        : 0o666;
    const flag = typeof options.flag !== "undefined"
        ? options.flag
        : "w";
    const data = typeof textOrBinary === "string" ? utf8Encode(textOrBinary) : textOrBinary;
    const array = normalizeBinary(data);
    if (!array) {
        throw new Error("Unable to normalize data");
    }
    return { mode, flag, array };
}

export { readFileSync, readdirSync, unlinkSync, writeFileSync };
