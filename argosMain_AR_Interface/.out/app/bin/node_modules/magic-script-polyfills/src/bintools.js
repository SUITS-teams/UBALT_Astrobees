/**
 * @param {Uint8Array} bin
 * @param {number} start
 * @param {number} end
 * @returns {string}
 */
function binToRaw (bin, start, end) {
  if (!(bin instanceof Uint8Array)) bin = new Uint8Array(bin);
  start = start == null ? 0 : start | 0;
  end = end == null ? bin.length : end | 0;
  let raw = '';
  for (let i = start || 0; i < end; i++) {
    raw += String.fromCharCode(bin[i]);
  }
  return raw;
}

/**
 * @param {string} hex
 * @param {number} start
 * @param {number} end
 * @returns {Uint8Array}
 */
function hexToBin (hex, start, end) {
  hex = '' + hex;
  start = start == null ? 0 : start | 0;
  end = end == null ? hex.length : end | 0;
  let len = (end - start) >> 1;
  let bin = new Uint8Array(len);
  let offset = 0;
  for (let i = start; i < end; i += 2) {
    bin[offset++] = parseInt(hex.substr(i, 2), 16);
  }
  return bin;
}

/**
 * @param {string} raw
 * @returns {string}
 */
function rawToStr (raw) {
  return decodeURIComponent(escape(raw));
}

function getCodes () {
  return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
}

// Loop over input 3 bytes at a time
// a,b,c are 3 x 8-bit numbers
// they are encoded into groups of 4 x 6-bit numbers
// aaaaaa aabbbb bbbbcc cccccc
// if there is no c, then pad the 4th with =
// if there is also no b then pad the 3rd with =
/**
 * @param {Uint8Array} bin
 * @returns {string}
 */
function binToB64 (bin) {
  let b64 = '';
  let codes = getCodes();
  for (let i = 0, l = bin.length; i < l; i += 3) {
    let a = bin[i];
    let b = i + 1 < l ? bin[i + 1] : -1;
    let c = i + 2 < l ? bin[i + 2] : -1;
    b64 +=
      // Higher 6 bits of a
      codes[a >> 2] +
      // Lower 2 bits of a + high 4 bits of b
      codes[((a & 3) << 4) | (b >= 0 ? b >> 4 : 0)] +
      // Low 4 bits of b + High 2 bits of c
      (b >= 0 ? codes[((b & 15) << 2) | (c >= 0 ? c >> 6 : 0)] : '=') +
      // Lower 6 bits of c
      (c >= 0 ? codes[c & 63] : '=');
  }
  return b64;
}

/**
 * @param {Uint8Array} bin
 * @param {number} [start]
 * @param {number} [end]
 * @returns {string}
 */
function binToStr (bin, start, end) {
  return rawToStr(binToRaw(bin, start, end));
}

/**
 * @param {string} hex
 * @returns {string}
 */
function hexToB64 (hex) {
  return binToB64(hexToBin(hex));
}

// This takes nested lists of numbers, strings and array buffers and returns
// a single buffer.  Numbers represent single bytes, strings are raw 8-bit
// strings, and buffers represent themselves.
// EX:
//    1           -> <01>
//    "Hi"        -> <48 69>
//    [1, "Hi"]   -> <01 48 69>
//    [[1],2,[3]] -> <01 02 03>
/**
 * @param {any} parts
 * @returns {Uint8Array}
 */
function flatten (parts) {
  if (typeof parts === 'number') return new Uint8Array([parts]);
  if (parts instanceof Uint8Array) return parts;
  if (parts instanceof ArrayBuffer) return new Uint8Array(parts);
  let buffer = new Uint8Array(count(parts));
  copy(buffer, 0, parts);
  return buffer;
}

function count (value) {
  if (value == null) return 0;
  if (typeof value === 'number') return 1;
  if (typeof value === 'string') return value.length;
  if (value instanceof Uint8Array) return value.length;
  if (value instanceof ArrayBuffer) return value.byteLength;
  if (!Array.isArray(value)) {
    print('VALUE', value);
    throw new TypeError('Bad type for flatten: ' + typeof value);
  }
  let sum = 0;
  for (let piece of value) {
    sum += count(piece);
  }
  return sum;
}

function copy (buffer, offset, value) {
  if (value == null) return offset;
  if (typeof value === 'number') {
    buffer[offset++] = value;
    return offset;
  }
  if (typeof value === 'string') {
    for (let i = 0, l = value.length; i < l; i++) {
      buffer[offset++] = value.charCodeAt(i);
    }
    return offset;
  }
  if (value instanceof ArrayBuffer) {
    value = new Uint8Array(value);
  }
  for (let piece of value) {
    offset = copy(buffer, offset, piece);
  }
  return offset;
}

/**
 * indexOf for arrays/buffers.  Raw is a string in raw encoding.
 * returns -1 when not found.
 * start and end are indexes into buffer.  Default is 0 and length.
 * @param {Uint8Array} bin
 * @param {string} raw
 * @param {number} start
 * @param {number} end
 * @returns {number}
 */
function indexOf (bin, raw, start, end) {
  /* eslint-disable no-labels */
  start = start == null ? 0 : start | 0;
  end = end == null ? bin.length : end | 0;
  outer: for (let i = start || 0; i < end; i++) {
    for (let j = 0, l = raw.length; j < l; j++) {
      if (i + j >= end || bin[i + j] !== raw.charCodeAt(j)) {
        continue outer;
      }
    }
    return i;
  }
  return -1;
}

/**
 * @param {number} num
 * @returns {[number, number]}
 */
function uint16 (num) {
  num = (num >>> 0) & 0xffff;
  return [
    num >> 8,
    num & 0xff
  ];
}

/**
 * @param {number} num
 * @returns {[number, number, number, number]}
 */
function uint32 (num) {
  num >>>= 0;
  return [
    num >> 24,
    (num >> 16) & 0xff,
    (num >> 8) & 0xff,
    num & 0xff
  ];
}

/**
 *
 * @param {number} num
 * @returns {[[number, number, number, number],[number, number, number, number]]}
 */
function uint64 (num) {
  if (num < 0) num += 0x10000000000000000;
  return [
    uint32(num / 0x100000000),
    uint32(num % 0x100000000)
  ];
}

export { binToB64, binToRaw, binToStr, flatten, hexToB64, hexToBin, indexOf, rawToStr, uint16, uint32, uint64 };
